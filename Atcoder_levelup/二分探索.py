#二分探索は条件を満たす最大・最小を高速で探し出すアルゴリズム

#実装のコツ：左、右の区間をとって中央が条件を満たすか？を判定し区間を狭めていく
"""「○○以上のうち最小」を探す二分探索のコツは
条件満たす 左=中央、条件を満たさない 右=中央を満たすを常に満たすように範囲を更新
「○○以下のうち最大」を探す場合はこれらが逆になる。"""

# 入力の受け取り
N,Q=map(int,input().split())
A=list(map(int,input().split()))

# Aをソート
A.sort()

# 二分探索
# 引数：x 返り値：「身長がx以上の中で最も小さい人は何番目か」全体ー最小番号＝超えている人の数
def Nibutan(x):  
    # 左端
    l=0
    # 右端
    r=N-1

    # 1<右端-左端の間
    while 1<r-l:
        # 中央
        c=(l+r)//2

        # A[c]<xならば(条件を満たさない場合)
        if A[c]<x:
            # 左端を中央へ更新
            l=c
        # そうでなければ(x≤A[c] 条件を満たす場合)
        else:
            # 右端を中央へ更新
            r=c  #x以上の人の最小インデックス番号を返す
       
    # 右端を返す
    return r

# Q回
for i in range(Q):
    # 入力の受け取り
    x=int(input())

    # xがAの中で最小の要素以下である場合
    if x<=A[0]:
        # N人
        print(N)
    # xがAの中で最大の要素より大きい場合
    elif A[N-1]<x:
        print(0)
    # それ以外
    else:
        # 答えの出力
        print(N-Nibutan(x))
